package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen

import (
	"context"
	"log"
	"time"

	"github.com/mxcoppell/graphql-resolver-batch-cache/graph/loaders"
	"github.com/mxcoppell/graphql-resolver-batch-cache/graph/model"
)

// NextExDividendDate is the resolver for the NextExDividendDate field.
func (r *symbolDefinitionResolver) NextExDividendDate(ctx context.Context, obj *model.SymbolDefinition, useCache *bool) (*time.Time, error) {
	log.Printf("Resolving NextExDividendDate for symbol %s (useCache: %v)", obj.Name, useCache)

	// Get the loader from context
	loader := loaders.For(ctx)

	// Determine if we should use cache (default to true if not specified)
	shouldUseCache := true
	if useCache != nil {
		shouldUseCache = *useCache
	}

	// Load the dividend date using the loader
	dateResult, err := loader.LoadDividendDate(ctx, obj.Name, shouldUseCache)
	if err != nil || dateResult == nil {
		return nil, err
	}

	// Convert model.Date to time.Time
	return &dateResult.Time, nil
}

// Symbols is the resolver for the symbols field.
func (r *queryResolver) Symbols(ctx context.Context, names []string) ([]*model.SymbolDefinition, error) {
	log.Printf("Query.symbols called with %d symbols", len(names))

	// Create symbol definitions for each name
	result := make([]*model.SymbolDefinition, len(names))
	for i, name := range names {
		// Here we create model objects with just the name filled in
		// NextExDividendDate will be resolved separately when requested
		result[i] = &model.SymbolDefinition{
			Name:        name,
			Description: nil,
		}
	}

	return result, nil
}

// SymbolUpdates is the resolver for the symbolUpdates field.
func (r *subscriptionResolver) SymbolUpdates(ctx context.Context, names []string) (<-chan *model.SymbolDefinition, error) {
	log.Printf("Subscription.symbolUpdates called with %d symbols", len(names))

	// Create a channel to send updates
	ch := make(chan *model.SymbolDefinition, 1)

	// Start a goroutine to send periodic updates
	go func() {
		defer close(ch)

		// Keep track of the current index in the names slice
		index := 0

		// Send an update every second until context is cancelled
		ticker := time.NewTicker(1 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				// Get the current symbol name
				name := names[index]

				// Create a symbol definition
				symbol := &model.SymbolDefinition{
					Name:        name,
					Description: nil,
				}

				// Send it to the channel
				ch <- symbol

				// Move to the next name
				index = (index + 1) % len(names)
			}
		}
	}()

	return ch, nil
}

// SymbolDefinition returns SymbolDefinitionResolver implementation.
func (r *Resolver) SymbolDefinition() SymbolDefinitionResolver { return &symbolDefinitionResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type symbolDefinitionResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
